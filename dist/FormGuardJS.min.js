/**
 * FormGuardJS - A lightweight form validation library
 * 
 * Version: 1.0.2
 * 
 * Copyright (c) 2024 Jishith MP
 * 
 * This software is released under the MIT License.
 * 
 * Author: Jishith MP
 * License: MIT
 */


const styles = document.createElement("style");
styles.innerHTML = `
    .formGuard_error-message{color:red;font-size:0.9em;margin-bottom:10px;}
    .formGuard_error-field{border-color:red;}
`;
document.head.insertBefore(styles, document.head.firstChild);
class FormGuard { constructor(r, e = {}) { this.form = r;
    this.options = e;
    this.errors = {}; if (!this.options.onSubmit || typeof this.options.onSubmit !== "function") { throw new Error("The `onSubmit` callback is required and must be a function.") } this.initialize() } initialize() { this.form.addEventListener("submit", async r => { this.clearErrorMessages(); const e = this.form.querySelectorAll("input, textarea"); let t = true;
      e.forEach(r => { if (!r.name) { t = false } });
      this.init(); if (!t || Object.keys(this.errors).length > 0) { r.preventDefault(); return } r.preventDefault(); try { await this.options.onSubmit(new FormData(this.form), r) } catch (s) {} }) } init() { this.clearErrors(); const r = this.form.querySelectorAll("input, textarea");
    r.forEach(r => { try { const t = r.dataset.rules ? JSON.parse(r.dataset.rules) : {}; if (!r.dataset.rules) {} if (t.required && !r.value.trim()) { this.addError(r, t.messages?.required || "This field is required");
          this.applyErrorStyle(r) } if (r.type === "number" && r.value.trim() !== "") { if (t.min && r.value < t.min) { this.addError(r, t.messages?.min || `Minimum value is ${t.min}`);
            this.applyErrorStyle(r) } if (t.max && r.value > t.max) { this.addError(r, t.messages?.max || `Maximum value is ${t.max}`);
            this.applyErrorStyle(r) } } if (r.type === "email") { const s = /^[^\s@]+@[^\s@]+\.[^\s@]+$/; if (t.required === true && !r.value.trim()) { this.addError(r, t.messages?.required || "Email is required");
            this.applyErrorStyle(r) } else if (r.value.trim() !== "" && !s.test(r.value)) { this.addError(r, t.messages?.invalid || "Please enter a valid email address");
            this.applyErrorStyle(r) } } if (r.type === "password") this.validatePassword(r, t.password || {}); if (r.type === "checkbox" && t.required) { const a = this.form.querySelectorAll(`input[name="${r.name}"]`); const i = Array.from(a).some(r => r.checked); if (!i) { this.addError(r, t.messages?.required || "At least one option must be selected");
            this.applyErrorStyle(r) } } if (r.type === "text" || r.tagName.toLowerCase() === "textarea") { const o = t.minLength || null; const l = t.maxLength || null; if (r.value.trim() !== "") { if (o && r.value.length < o) { this.addError(r, t.messages?.minLength || `Must be at least ${o} characters`);
              this.applyErrorStyle(r) } if (l && r.value.length > l) { this.addError(r, t.messages?.maxLength || `Must be no more than ${l} characters`);
              this.applyErrorStyle(r) } } } if (r.type === "url") { const n = /^(ftp|http|https):\/\/[^ "]+$/; if (t.required === true && !r.value.trim()) { this.addError(r, t.messages?.required || "URL is required");
            this.applyErrorStyle(r) } else if (r.value.trim() !== "" && !n.test(r.value)) { this.addError(r, t.messages?.invalid || "Please enter a valid URL");
            this.applyErrorStyle(r) } } if (r.type === "radio" && t.required) { const m = this.form.querySelectorAll(`input[name="${r.name}"]`); const i = Array.from(m).some(r => r.checked); if (!i) { this.addError(r, t.messages?.required || "Please select an option");
            this.applyErrorStyle(r) } } } catch (e) {} });
    this.showErrors() } validatePassword(r, e) { const { minLength: t = 8, capitalLetters: s = 1, smallLetters: a = 1, numbers: i = 1, symbols: o = 1, messages: l = {} } = e; let n = r.value; let m = (n.match(/[A-Z]/g) || []).length; let d = (n.match(/[a-z]/g) || []).length; let h = (n.match(/\d/g) || []).length; let u = (n.match(/[\W_]/g) || []).length; if (n.length < t) { this.addError(r, l.minLength || `Password must be at least ${t} characters`);
      this.applyErrorStyle(r) } if (m < s) { this.addError(r, l.capitalLetters || `Password must contain at least ${s} capital letter(s)`);
      this.applyErrorStyle(r) } if (d < a) { this.addError(r, l.smallLetters || `Password must contain at least ${a} small letter(s)`);
      this.applyErrorStyle(r) } if (h < i) { this.addError(r, l.numbers || `Password must contain at least ${i} number(s)`);
      this.applyErrorStyle(r) } if (u < o) { this.addError(r, l.symbols || `Password must contain at least ${o} symbol(s)`);
      this.applyErrorStyle(r) } } addError(r, e) { this.errors[r.name] = e } clearErrors() { this.errors = {} } applyErrorStyle(r) { r.classList.add("formGuard_error-field") } showErrors() { for (const r in this.errors) { const e = this.form.querySelector(`[name="${r}"]`); const t = document.createElement("div");
      t.classList.add("formGuard_error-message");
      t.textContent = this.errors[r];
      e.parentNode.insertBefore(t, e.nextSibling) } } clearErrorMessages() { document.querySelectorAll(".formGuard_error-message").forEach(r => r.remove());
    document.querySelectorAll(".formGuard_error-field").forEach(r => r.classList.remove("formGuard_error-field")) } }